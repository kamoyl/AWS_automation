#!/usr/bin/env bash

START_AWS_TIME=$(date +%s.%4N)

if [[ "${OSTYPE}" =~ "linux" ]]
then
  SCRIPT=$(readlink -f "$0")
elif [[ "${OSTYPE}" =~ "darwin" ]]
then
  SCRIPT=$(greadlink -f "$0")
else
  SCRIPT=$(readlink -f "$0")
fi

SCRIPTS_HOME=$(dirname "${SCRIPT}")

PARAMETERS=$(echo "$@" | sed 's/\-l .//g')

if [ $(caller | awk '{print $1}') -eq 0 ]
then
  CALLING=0
  source "${SCRIPTS_HOME}/config"
  echo -e "${BLUE}${datestring} EXECUTE: ${YELLOW}[ ${LIME}$0 ${PARAMETERS} ${YELLOW} ]${RESET}"
else
  CALLING=1
  if [[ ${VERBOSE} == yes ]]
  then
    debug "${YELLOW}[ ${LIME}$(echo $(caller | awk '{print $2}') | awk -F\/ '{print $NF}') ${YELLOW}calls (in line: ${LIME}$(caller | awk '{print $1}')${YELLOW}) ${LIME}$(echo ${BASH_SOURCE} | awk -F\/ '{print $NF}') ${PARAMETERS} ${YELLOW} ]"
  fi
fi

usage()
{
echo "
${CYAN}Usage:${BRIGHT}${WHITE}
$0 [-o DIRECTORY] -v [-O OWNER_ID] [-C] [-p] [-x] [-I]

    ${NORMAL}${CYAN}This script checks and looks for difference between repositories and
        ENV - and take some actions later on, producting report of what has been done${BLUE}
    ${LIME}-o${BLUE}  OUTPUT directory - where to store ALL LOGs and TEMP files
        (default directory is: ${CYAN}${HOME}/var${BLUE} and TMP and LOG are subdirectories to var)
    ${LIME}-p${BLUE}  ${RED}[mandatory outside AWS env]${BLUE} - ${BROWN}PROFILE${BLUE} name stored in ~/.aws/config
    ${LIME}-C${BLUE}  CLEANING (${WINE}WARNING${BLUE}) - removing all running/stopped instance(s) (terminates them) and all volumes
    ${LIME}-I${BLUE}  ${WINE}[optional]${BLUE} - ${BROWN}INSTANCE_TYPE${BLUE}  (if ommited, then ${YELLOW}\"t3.small\"${BLUE} is picked up)
    ${LIME}-x${BLUE}  only works with [-C] - CLEANING (${RED}WARNING${BLUE}) - removes: S3 buckets (only empty), Lambda functions, events-busses etc.
    ${LIME}-v${BLUE}  verbose${RESET}"
    1>&2;
    exit 1
}

VERBOSE=no
REDEPLOYMENT=no
CLEANING=no
XTRA_CLEANING=no
AMI_TOBE_REMOVED=""
while getopts ":o:p:I:vCx" ARG
do
  case "${ARG}" in
        v)
            VERBOSE=yes
            ;;
        C)
            CLEANING=yes
            ;;
        x)  XTRA_CLEANING=yes
            ;;
        p)
            p=${OPTARG}
            AWS_PROFILE=${p}
            ;;
        I)
            I=${OPTARG}
            AWS_INSTANCE_TYPE=${I}
            ;;
        o)
            o=${OPTARG}
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

if [[ ${AWS_ZONE} == "Y" ]]
then
  if [ ! -z ${AWS_PROFILE} ]
  then
    AWS_PROFILE=""
  fi
elif [[ ${AWS_ZONE} == "N" ]]
then
  if [ -z ${AWS_PROFILE} ]
  then
    error "Lack of mandatory parameter(s): ${LIME}AWS profile (-p)"
    usage
  fi
fi

if [[ ${HOSTNAME_FQDN} =~ eu-west-1.compute.internal ]]
then
  AWS_PROFILE_USE_CHECK=""
else
  AWS_PROFILE_USE_CHECK=(--profile ${AWS_PROFILE})
fi

if [ -z ${I} ]
then
  AWS_INSTANCE_TYPE="t3.small"
  #AWS_INSTANCE_TYPE="t2.micro"
  #AWS_INSTANCE_TYPE="t3.xlarge"
  I=${AWS_INSTANCE_TYPE}
fi

if [ ${CALLING} -eq 0 ]
then
  source "${SCRIPTS_HOME}/var_management"
fi

#AWS checking connection
start_time_collecting
aws_connectivity_check
end_time_collecting
CONNECTIVITY_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  connectivity check time: ${ORANGE}${CONNECTIVITY_CHECK_TIME}"
fi
#AWS checking connection
#AWS collecting most of the data
start_time_collecting
source "${SCRIPTS_HOME}/aws_collecting"
wait
end_time_collecting
AWS_COLLECTING_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  collecting data time: ${ORANGE}${AWS_COLLECTING_TIME}"
fi
#AWS collecting most of the data

if [[ ${CURRENT_DAY} == 01 ]] && [[ ${CURRENT_MONTH} == 01 ]]
then
  CURRENT_MONTH_COSTS="0"
  CURRENT_YEAR_COSTS="0"
elif [[ ${CURRENT_DAY} == 01 ]]
then
  CURRENT_MONTH_COSTS="0"
  CURRENT_YEAR_COSTS=$(jq -r '.ResultsByTime[].Total[].Amount' "${TMP}/${AWS_COSTS_DETAILS}_full.json" | awk '{sum+=$1} END {print sum}')
  CURRENT_YEAR_COSTS=${CURRENT_YEAR_COSTS%.*}
else
  CURRENT_MONTH_COSTS=$(jq -r '.ResultsByTime[].Groups[] | .Keys[] + "~" + .Metrics.NetAmortizedCost.Amount' "${TMP}/${AWS_COSTS_DETAILS}_current_month_full.json" | awk -F\~ '{sum+=$2} END {print sum}')
  CURRENT_MONTH_COSTS=${CURRENT_MONTH_COSTS%.*}
  CURRENT_YEAR_COSTS=$(jq -r '.ResultsByTime[].Total[].Amount' "${TMP}/${AWS_COSTS_DETAILS}_full.json" | awk '{sum+=$1} END {print sum}')
  CURRENT_YEAR_COSTS=${CURRENT_YEAR_COSTS%.*}
fi

#AWS network
start_time_collecting
#VPCs
if [ -s "${TMP}/${AWS_VPCS}_full.json" ]
then
  if [[ ${VERBOSE} == yes ]]
  then
    inf ""
    inf "${MAGENTA}AWS VPCs:"
    for VPC_ID in $(jq -r '.Vpcs[].VpcId' "${TMP}/${AWS_VPCS}_full.json")
    do
      inf "  VpcID: ${YELLOW}${VPC_ID}"
      #for VPC_CIDR_BLOCK in $(jq -r --arg vpc_id ${VPC_ID} '.Vpcs[].CidrBlockAssociationSet[].CidrBlock' "${TMP}/${AWS_VPCS}_full.json")
      for VPC_CIDR_BLOCK in $(jq -r --arg vpc_id ${VPC_ID} '.Vpcs[] | select(.VpcId == $vpc_id) | .CidrBlockAssociationSet[].CidrBlock' "${TMP}/${AWS_VPCS}_full.json")
      do
        inf "    CidrBlock: ${LIME}${VPC_CIDR_BLOCK}"
      done
    done
  fi
else
  warn "  There is no VPC(s)"
fi
#IGW
if [ -s "${TMP}/${AWS_IGWS}_full.json" ]
then
  if [[ ${VERBOSE} == yes ]]
  then
    inf ""
    inf "${MAGENTA}AWS IGWs:"
    for IGW_ID in $(jq -r '.InternetGateways[].InternetGatewayId' "${TMP}/${AWS_IGWS}_full.json")
    do
      inf "  IgwID: ${YELLOW}${IGW_ID}"
      VPC_ID_IGW=$(jq -r --arg igw_id ${IGW_ID} '.InternetGateways[] | select(.InternetGatewayId == $igw_id) | .Attachments[].VpcId' "${TMP}/${AWS_IGWS}_full.json")
      inf "    attached to VpcID: ${YELLOW}${VPC_ID_IGW}"
    done
  fi
else
  warn "  There is no IGW(s)"
fi

#NAT GW
if [[ ${VERBOSE} == yes ]]
then
  inf ""
  inf "${MAGENTA}AWS NAT GWs:"
  if [ -s "${TMP}/${AWS_NAT_GWS}_full.json" ] && [ ! -z $(jq -r '.NatGateways[]' "${TMP}/${AWS_NAT_GWS}_full.json" | head -n1) ]
  then
    GW_ID=$(jq -r '.NatGateways[].NatGatewayId' "${TMP}/${AWS_NAT_GWS}_full.json")
    SUBNET_ID=$(jq -r '.NatGateways[].SubnetId' "${TMP}/${AWS_NAT_GWS}_full.json")
    VPC_ID=$(jq -r '.NatGateways[].VpcId' "${TMP}/${AWS_NAT_GWS}_full.json")
    for NET_ID in $(jq -r '.NatGateways[].NatGatewayAddresses[].NetworkInterfaceId' "${TMP}/${AWS_NAT_GWS}_full.json")
    do
      PRIVATE_IP=$(jq -r --arg net_id ${NET_ID} '.NatGateways[].NatGatewayAddresses[] | select(.NetworkInterfaceId == $net_id) | .PrivateIp' "${TMP}/${AWS_NAT_GWS}_full.json")
      PUBLIC_IP=$(jq -r --arg net_id ${NET_ID} '.NatGateways[].NatGatewayAddresses[] | select(.NetworkInterfaceId == $net_id) | .PublicIp' "${TMP}/${AWS_NAT_GWS}_full.json")
    done
    inf "  NAT gateway: ${YELLOW}${GW_ID}${CYAN}, for subnet ID: ${DARK_GREEN}${SUBNET_ID}"
    inf "    network ID: ${YELLOW}${NET_ID}"
    inf "      with private IP: ${LIME}${PRIVATE_IP}"
    inf "      with public IP: ${LIME}${PUBLIC_IP}"
  else
    warn "  There is no NAT GW(s)"
  fi
fi

#routing tables
if [[ ${VERBOSE} == yes ]]
then
  inf ""
  inf "${MAGENTA}AWS routing tables:"
  if [ -s "${TMP}/${AWS_ROUTE_TBLS}_full.json" ] && [ ! -z $(jq -r '.RouteTables[]' "${TMP}/${AWS_ROUTE_TBLS}_full.json" | head -n1) ] 
  then
      for ROUTING_TABLE in $(jq -r '.RouteTables[].RouteTableId' "${TMP}/${AWS_ROUTE_TBLS}_full.json")
      do
        inf "  Routing table ID: ${LIME}${ROUTING_TABLE}"
      done
  else
    warn "  There is no routing table(s)"
  fi
fi

#subnets
if [ -s "${TMP}/${AWS_SUBNETS_DETAILS}_full.json" ]
then
  if [[ ${VERBOSE} == yes ]]
  then
    inf ""
    inf "${MAGENTA}AWS subnets:"
    for AWS_SUBNET_ID in $(jq -r '.Subnets[] | .SubnetId' "${TMP}/${AWS_SUBNETS_DETAILS}_full.json")
    do
      (
      SUBNET_NAME=$(jq -r --arg subnet_id ${AWS_SUBNET_ID} '.Subnets[] | select(.SubnetId == $subnet_id) | .Tags[].Value' "${TMP}/${AWS_SUBNETS_DETAILS}_full.json" 2>/dev/null)
      SUBNET_CIDR=$(jq -r --arg subnet_id ${AWS_SUBNET_ID} '.Subnets[] | select(.SubnetId == $subnet_id) | .CidrBlock' "${TMP}/${AWS_SUBNETS_DETAILS}_full.json")
      SUBNET_AVAILABLE_ADDRESS=$(jq -r --arg subnet_id ${AWS_SUBNET_ID} '.Subnets[] | select(.SubnetId == $subnet_id) | .AvailableIpAddressCount' "${TMP}/${AWS_SUBNETS_DETAILS}_full.json")
      SUBNET_ID=$(jq -r --arg subnet_id ${AWS_SUBNET_ID} '.Subnets[] | select(.SubnetId == $subnet_id) | .SubnetId' "${TMP}/${AWS_SUBNETS_DETAILS}_full.json")
      SUBNET_ARN="$(jq -r --arg subnet_id ${AWS_SUBNET_ID} '.Subnets[] | select(.SubnetId == $subnet_id) | .SubnetArn' "${TMP}/${AWS_SUBNETS_DETAILS}_full.json")"
      SUBNET_AVAILABILITY_ZONE=$(jq -r --arg subnet_id ${AWS_SUBNET_ID} '.Subnets[] | select(.SubnetId == $subnet_id) | .AvailabilityZone' "${TMP}/${AWS_SUBNETS_DETAILS}_full.json")
      inf "  Subnet ${DARK_GREEN}${SUBNET_ID} ${CYAN}(tag: ${YELLOW}${SUBNET_NAME}${CYAN}, availability zone: ${YELLOW}${SUBNET_AVAILABILITY_ZONE}${CYAN}), ${LIME}${SUBNET_CIDR}${CYAN}, free IPs: ${BROWN}${SUBNET_AVAILABLE_ADDRESS}"
      ) &
    done
  fi
else
  warn "  There is no subnets (really???)"
fi
wait
end_time_collecting
NETWORK_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  network check time: ${ORANGE}${CONNECTIVITY_CHECK_TIME}"
fi
#AWS network

#AWS Instances
start_time_collecting
inf ""
inf "${MAGENTA}EC2 Instances:"
if [ -s "${TMP}/${AWS_INSTANCES_DETAILS}_full.json" ] && [ ! -z $(jq -r '.Reservations[].Instances[].InstanceId' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json" | head -n1) ]
then
  for AWS_INSTANCE_ID in $(jq -r '.Reservations[].Instances[].InstanceId' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
  do
    AWS_INSTANCE_IP=$(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Reservations[].Instances[] | select(.InstanceId == $aws_instance_id) | .PrivateIpAddress' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
    AWS_INSTANCE_PUBLIC_IP=$(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Reservations[].Instances[] | select(.InstanceId == $aws_instance_id) | .PublicIpAddress' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
    AWS_INSTANCE_LAUNCH=$(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Reservations[].Instances[] | select(.InstanceId == $aws_instance_id) | .LaunchTime' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
    AWS_INSTANCE_MONITORING_CHECK=$(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Reservations[].Instances[] | select(.InstanceId == $aws_instance_id) | .Monitoring | .State' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
    AWS_INSTANCE_LAUNCH_DATE=$(echo ${AWS_INSTANCE_LAUNCH} | awk -FT '{print $1}')
    AWS_INSTANCE_LAUNCH_TIME=$(echo ${AWS_INSTANCE_LAUNCH} | awk -FT '{print $2}' | awk -F\+ '{print $1}')
    AWS_INSTANCE_LSECONDS=$(date -d"${AWS_INSTANCE_LAUNCH_DATE}T${AWS_INSTANCE_LAUNCH_TIME}" +%s)
    AWS_INSTANCE_SECONDS=$(echo "${NOW_SECONDS} - ${AWS_INSTANCE_LSECONDS}" | bc)
    AWS_INSTANCE_DAYS=$(echo "${AWS_INSTANCE_SECONDS} / 3600 / 24" | bc)
    AWS_INSTANCE_TYPE=$(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Reservations[].Instances[] | select(.InstanceId == $aws_instance_id) | .InstanceType' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
    AWS_INSTANCE_STATE=$(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Reservations[].Instances[] | select(.InstanceId == $aws_instance_id) | .State.Name' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
    AWS_VOLUMES=$(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Reservations[].Instances[] | select(.InstanceId == $aws_instance_id) | .BlockDeviceMappings[].Ebs.VolumeId' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
    if [ ${AWS_INSTANCE_DAYS} -eq 1 ]
    then
      WHEN_RUN="yesterday"
    elif [ ${AWS_INSTANCE_DAYS} -lt 1 ]
    then
      WHEN_RUN="today"
    else
      WHEN_RUN="${AWS_INSTANCE_DAYS} days ago"
    fi
    if [[ ${AWS_ZONE} == "Y" ]] && [[ ${AWS_INSTANCE_ID} == ${LOCAL_EC2_INSTANCE} ]]
    then
      CHECKED_INSTANCE_PROFILE="$(jq -r --arg local_ec2_instance ${LOCAL_EC2_INSTANCE} '.Reservations[].Instances[] | select(.InstanceId == $local_ec2_instance) | .IamInstanceProfile.Arn' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json" | awk -F\/ '{print $NF}')"
      CHECKED_INSTANCE_PROFILE_ROLE=$(jq -r --arg local_ec2_instance_profile ${CHECKED_INSTANCE_PROFILE} '.InstanceProfiles[] | select(.InstanceProfileName == $local_ec2_instance_profile) | .Roles[].RoleName' "${TMP}/${AWS_INSTANCE_PROFILES}_full.json" | head -n1)
      inf "  EC2 instance ID: ${YELLOW}${AWS_INSTANCE_ID}${CYAN}, type ${LIME}${AWS_INSTANCE_TYPE} ${CYAN}(${DARK_GREEN}CURRENT INSTANCE${CYAN})"
      if [[ ${VERBOSE} == yes ]]
      then
        debug "   current instance profile: ${YELLOW}${CHECKED_INSTANCE_PROFILE}"
        debug "   with role: ${YELLOW}${CHECKED_INSTANCE_PROFILE_ROLE}"
      fi
    else
      inf "  EC2 instance ID: ${YELLOW}${AWS_INSTANCE_ID}${CYAN}, type ${LIME}${AWS_INSTANCE_TYPE}"
    fi
    inf "    recent start: ${WINE}${AWS_INSTANCE_LAUNCH_DATE} at ${AWS_INSTANCE_LAUNCH_TIME}${CYAN} (${YELLOW}${WHEN_RUN}${CYAN})"
    if [[ ${AWS_INSTANCE_STATE} == "stopped" ]]
    then
      inf "    state: ${RED}${AWS_INSTANCE_STATE^^}"
      inf "      Private IP: ${LIME}${AWS_INSTANCE_IP}"
      if [ -z ${AWS_INSTANCE_PUBLIC_IP} ] || [[ ${AWS_INSTANCE_PUBLIC_IP} == "null" ]]
      then
        inf "      Public  IP: ${WINE}none"
      fi
    elif [[ ${AWS_INSTANCE_STATE} == "running" ]]
    then
      inf "      state: ${GREEN}${AWS_INSTANCE_STATE^^}"
      inf "        Private IP: ${LIME}${AWS_INSTANCE_IP}"
      if [ -z ${AWS_INSTANCE_PUBLIC_IP} ] || [[ ${AWS_INSTANCE_PUBLIC_IP} == "null" ]]
      then
        inf "        Public  IP: ${WINE}none"
      fi
    else
      inf "      state: ${WINE}${AWS_INSTANCE_STATE^^}"
    fi
    for AWS_INSTANCE_VOL in $(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Reservations[].Instances[] | select(.InstanceId == $aws_instance_id) | .BlockDeviceMappings[].Ebs.VolumeId' "${TMP}/${AWS_INSTANCES_DETAILS}_full.json")
    do
      AWS_INSTANCE_VOL_E2_SNAP=$(jq -r --arg aws_instance_id ${AWS_INSTANCE_ID} '.Volumes[] | select(.Attachments[].InstanceId == $aws_instance_id) | .SnapshotId' "${TMP}/${AWS_VOLS_DETAILS}_full.json")
      inf "          device mapping: ${YELLOW}${AWS_INSTANCE_VOL}"
      inf "            E2 snapshot: ${BROWN}${AWS_INSTANCE_VOL_E2_SNAP}"
      if [ -s "${TMP}/${AWS_SNAPS_DETAILS}_full.json" ]
      then
        IFS=${NEWIFS}
        for AWS_S3_SNAPSHOT_VOL_ID in $(jq -r --arg aws_instance_vol ${AWS_INSTANCE_VOL} '.Snapshots[] | select(.VolumeId == $aws_instance_vol) | .SnapshotId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        do
          AWS_S3_SNAPSHOT_DESCRIPTION=$(jq -r --arg aws_s3_snapshot_id ${AWS_S3_SNAPSHOT_VOL_ID} '.Snapshots[] | select(.SnapshotId == $aws_s3_snapshot_id) | .Description' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
          AWS_S3_SNAPSHOT_CREATED=$(jq -r --arg aws_s3_snapshot_id ${AWS_S3_SNAPSHOT_VOL_ID} '.Snapshots[] | select(.SnapshotId == $aws_s3_snapshot_id) | .StartTime' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
          AWS_S3_SNAPSHOT_CREATED_DATE=$(echo ${AWS_S3_SNAPSHOT_CREATED} | awk -FT '{print $1}')
          AWS_S3_SNAPSHOT_CREATED_TIME=$(echo ${AWS_S3_SNAPSHOT_CREATED} | awk -FT '{print $2}' | awk -F\. '{print $1}')
          AWS_S3_SNAPSHOT_CDATE="${AWS_S3_SNAPSHOT_CREATED_DATE}"
          AWS_S3_SNAPSHOT_CTIME="${AWS_S3_SNAPSHOT_CREATED_TIME}"
          AWS_S3_SNAPSHOT_CSECONDS=$(date -d"${AWS_S3_SNAPSHOT_CDATE}T${AWS_S3_SNAPSHOT_CTIME}" +%s)
          inf "              S3 snapshot: ${BROWN}${AWS_S3_SNAPSHOT_VOL_ID}, ${CYAN} created: ${WINE}${AWS_S3_SNAPSHOT_CDATE}${CYAN} at ${WINE}${AWS_S3_SNAPSHOT_CTIME} ${DARK_GREEN}(${AWS_S3_SNAPSHOT_DESCRIPTION:0:35}...)"
          AWS_S3_SNAPSHOT_SECONDS=$(echo "${NOW_SECONDS} - ${AWS_S3_SNAPSHOT_CSECONDS}" | bc)
          AWS_S3_SNAPSHOT_DAYS=$(echo "${AWS_S3_SNAPSHOT_SECONDS} / 3600 / 24" | bc)
          if [ ${AWS_S3_SNAPSHOT_SECONDS} -ge ${MONTH_SECONDS} ]
          then
            warn "       and is older then a ${RED}MONTH${WINE} (${RED}${AWS_S3_SNAPSHOT_DAYS} days${WINE}), then deleting it"
          elif [ ${AWS_S3_SNAPSHOT_SECONDS} -ge ${WEEK_SECONDS} ]
          then
            inf "        and it is older then a ${WINE}WEEK${CYAN} (${WINE}${AWS_S3_SNAPSHOT_DAYS} days${CYAN})"
          elif [ ${AWS_S3_SNAPSHOT_SECONDS} -ge ${DAY_SECONDS} ]
          then
            inf "        and it is ${YELLOW}${AWS_S3_SNAPSHOT_DAYS}${CYAN} days old"
          fi
        done
        IFS=${ORIGIFS}
      fi
      S3_SNAPSHOTS_AMOUNT=$(jq -r --arg aws_instance_vol ${AWS_INSTANCE_VOL} '.Snapshots[] | select(.VolumeId == $aws_instance_vol) | .SnapshotId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json" | wc -l)
    done
    echo "
              {
                  \\\"value\\\": \\\"${AWS_INSTANCE_ID} (${AWS_INSTANCE_STATE}, ${AWS_INSTANCE_TYPE})\\\",
                  \\\"short\\\": true
              },
              {
                  \\\"value\\\": \\\"${AWS_INSTANCE_IP}\\\",
                  \\\"short\\\": true
              },
              " >> "${TMP}/${AWS_INSTANCES_DETAILS}_slack.out"
    if [[ ${CLEANING} == yes ]]
    then
      if  [[ ${AWS_INSTANCE_STATE^^} == "TERMINATED" ]]
      then
        inf "    ${WINE}Terminating instance: ${YELLOW}${AWS_INSTANCE_ID}"
        inf  "      Instance ${YELLOW}${AWS_INSTANCE_ID}${CYAN} is already terminated..."
      elif [[ ${AWS_INSTANCE_ID} != ${LOCAL_EC2_INSTANCE} ]]
      then
        aws_instance_removal ${AWS_INSTANCE_ID}
      else
        warn "    ${YELLOW}${AWS_INSTANCE_ID}${WINE} is actual instance, omitting"
      fi
    fi
    if ([[ ${CLEANING} == no ]] && [[ ${XTRA_CLEANING} == no ]]) || [[ ${AWS_INSTANCE_STATE^^} != TERMINATED ]]
    then
      aws_instance_monitoring ${AWS_INSTANCE_ID}
    fi
  done
else
  if [[ ${VERBOSE} == yes ]]
  then
    warn "  There is no EC2 instance(s)"
  fi
fi
end_time_collecting
EC2_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  EC2 check time: ${ORANGE}${CONNECTIVITY_CHECK_TIME}"
fi
#AWS Instances

#AWS VOLUMEs
start_time_collecting
inf ""
inf "${MAGENTA}EC2 volumes"
if [ -s "${TMP}/${AWS_VOLS_DETAILS}_full.json" ] && [ ! -z $(jq -r '.Volumes[].VolumeId' "${TMP}/${AWS_VOLS_DETAILS}_full.json" | head -n1) ]
then
  for AWS_VOL_ID in $(jq -r '.Volumes[].VolumeId' "${TMP}/${AWS_VOLS_DETAILS}_full.json")
  do
    VOL_STATE=$(jq -r --arg aws_vol_id ${AWS_VOL_ID} '.Volumes[] | select(.VolumeId == $aws_vol_id) | .State' "${TMP}/${AWS_VOLS_DETAILS}_full.json")
    VOL_INSTANCE_ID=$(jq -r --arg aws_vol_id ${AWS_VOL_ID} '.Volumes[] | select(.VolumeId == $aws_vol_id) | .Attachments[].InstanceId' "${TMP}/${AWS_VOLS_DETAILS}_full.json")
    VOL_CREATE_TIME=$(jq -r --arg aws_vol_id ${AWS_VOL_ID} '.Volumes[] | select(.VolumeId == $aws_vol_id) | .CreateTime' "${TMP}/${AWS_VOLS_DETAILS}_full.json")
    VOL_CREATE_CTIME=$(echo ${VOL_CREATE_TIME} | awk -FT '{print $1}')
    VOL_CREATE_CDATE=$(echo ${VOL_CREATE_TIME} | awk -FT '{print $2}' | awk -F\. '{print $1}')
    VOL_CREATE_LSECONDS=$(date -d"${VOL_CREATE_CDATE}T${VOL_CREATE_CTIME}" +%s)
    VOL_CREATE_SECONDS=$(echo "${NOW_SECONDS} - ${VOL_CREATE_LSECONDS}" | bc)
    VOL_CREATE_DAYS=$(echo "${VOL_CREATE_SECONDS} / 3600 / 24" | bc)
    VOL_EC2_SNAPSHOT_ID=$(jq -r --arg aws_vol_id ${AWS_VOL_ID} '.Volumes[] | select(.VolumeId == $aws_vol_id) | .SnapshotId' "${TMP}/${AWS_VOLS_DETAILS}_full.json")
    VOL_EC2_SNAPSHOT_ENCRYPT_CHECK=$(jq -r --arg aws_vol_id ${AWS_VOL_ID} '.Volumes[] | select(.VolumeId == $aws_vol_id) | .Encrypted' "${TMP}/${AWS_VOLS_DETAILS}_full.json")
    if [[ ${VOL_EC2_SNAPSHOT_ENCRYPT_CHECK} == "true" ]]
    then
      VOL_EC2_SNAPSHOT_ENCRYPTKEY=$(jq -r --arg aws_vol_id ${AWS_VOL_ID} '.Volumes[] | select(.VolumeId == $aws_vol_id) | .KmsKeyId' "${TMP}/${AWS_VOLS_DETAILS}_full.json")
    fi
    if [ ${VOL_CREATE_DAYS} -eq 1 ]
    then
      WHEN_RUN="yesterday"
    elif [ ${VOL_CREATE_DAYS} -lt 1 ]
    then
      WHEN_RUN="today"
    else
      WHEN_RUN="${VOL_CREATE_DAYS} days ago"
    fi
    if [[ ${VOL_STATE} == available ]]
    then
      warn "  Volume: ${YELLOW}${AWS_VOL_ID}${RED} is not attached to any instance"
      inf "    created: ${WINE}${VOL_CREATE_CDATE} at ${VOL_CREATE_CTIME} ${CYAN}(${YELLOW}${WHEN_RUN}${CYAN})"
      if [[ ${CLEANING} == yes ]]
      then
        aws_vol_removal ${AWS_VOL_ID}
      fi
    elif [[ ${VOL_STATE} == in-use ]]
    then
      inf "  Volume: ${YELLOW}${AWS_VOL_ID}${GREEN} is attached ${CYAN}to instance: ${YELLOW}${VOL_INSTANCE_ID}"
      inf "    created: ${YELLOW}${WHEN_RUN}"
      inf "      EC2 snapshot: ${BROWN}${VOL_EC2_SNAPSHOT_ID}"
      if [[ ${VOL_EC2_SNAPSHOT_ENCRYPT_CHECK} == "true" ]]
      then
        inf "        encrypted with KeyID: ${LIGHT_BLUE}${VOL_EC2_SNAPSHOT_ENCRYPTKEY}"
      fi
    fi
    if [[ ${CLEANING} == yes ]]
    then
      if [ -s "${LOG}/${AWS_INSTANCES_DETAILS}_${VOL_INSTANCE_ID}_termination.log.json" ]
      then
        warn  "    Volume: ${YELLOW}${AWS_VOL_ID}${WINE} as attached to just terminated instance: ${YELLOW}${VOL_INSTANCE_ID}${WINE} - will be removed"
        aws_vol_removal ${AWS_VOL_ID}
      fi
    fi
    #ONLY S3 snapshots
    if [ -s "${TMP}/${AWS_SNAPS_DETAILS}_full.json" ]
    then
      AWS_S3_SNAPSHOTS=$(jq -r --arg volume_id ${AWS_VOL_ID} '.Snapshots[] | select(.VolumeId == $volume_id) |.SnapshotId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json" | head -n1)
      if [ -z ${AWS_S3_SNAPSHOTS} ]
      then
        warn "          S3 snapshot(s) doesn't exist"
      else
        for AWS_SNAPSHOT_ID in $(jq -r --arg volume_id ${AWS_VOL_ID} '.Snapshots[] | select(.VolumeId == $volume_id) | .SnapshotId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        do
          AWS_S3_SNAPSHOT_DESCRIPTION=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .Description' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
          AWS_S3_SNAPSHOT_PROGRESS=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .Progress' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
          AWS_S3_SNAPSHOT_CREATED=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .StartTime' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
          AWS_S3_SNAPSHOT_CREATED_DATE=$(echo ${AWS_S3_SNAPSHOT_CREATED} | awk -FT '{print $1}')
          AWS_S3_SNAPSHOT_CREATED_TIME=$(echo ${AWS_S3_SNAPSHOT_CREATED} | awk -FT '{print $2}' | awk -F\. '{print $1}')
          AWS_S3_SNAPSHOT_VOLUME_ID=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .VolumeId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
          inf "          S3 snapshot: ${BROWN}${AWS_SNAPSHOT_ID}${CYAN} created ${WINE}${AWS_S3_SNAPSHOT_CREATED_DATE} at ${AWS_S3_SNAPSHOT_CREATED_TIME}${CYAN} (${DARK_GREEN}${AWS_S3_SNAPSHOT_DESCRIPTION}${CYAN})"
        done
      fi
    fi
    #ONLY S3 snapshots
    echo "
              {
                  \\\"value\\\": \\\"${AWS_VOL_ID} (${VOL_STATE})\\\",
                  \\\"short\\\": true
              },
              {
                  \\\"value\\\": \\\"${WHEN_RUN}\\\",
                  \\\"short\\\": true
              },
              " >> "${TMP}/${AWS_VOLS_DETAILS}_slack.out"
  done
else
  if [[ ${VERBOSE} == yes ]]
  then
    warn "  There is no EC2 volume(s)"
  fi
fi
end_time_collecting
VOLUMES_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  volumes check time: ${ORANGE}${CONNECTIVITY_CHECK_TIME}"
fi
#AWS Volumes

#AWS S3 snapshots
start_time_collecting
inf ""
inf "${MAGENTA}S3 snapshot(s)"
if [ -s "${TMP}/${AWS_SNAPS_DETAILS}_full.json" ]
then
  AWS_S3_SNAPSHOTS=$(jq -r '.Snapshots[] | .SnapshotId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json" | head -n1)
  if [ -z ${AWS_S3_SNAPSHOTS} ]
  then
    warn "  S3 snapshot(s) doesn't exist"
  else
    for AWS_SNAPSHOT_ID in $(jq -r '.Snapshots[] | .SnapshotId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
    do
      (
        VOLUME_ID=$(jq -r --arg snap_id "${AWS_SNAPSHOT_ID}" '.Snapshots[] | select(.SnapshotId | contains($snap_id)) | .VolumeId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        if [ -s "${TMP}/${AWS_AMIS_DETAILS}_full.json" ]
        then
          AMI_ID_SNAPSHOT=$(jq -r --arg snap_id "${AWS_SNAPSHOT_ID}" '.Images[] | select(.BlockDeviceMappings[].Ebs.SnapshotId == $snap_id) | .ImageId' "${TMP}/${AWS_AMIS_DETAILS}_full.json")
        fi
        AWS_S3_SNAPSHOT_DESCRIPTION=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .Description' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        AWS_S3_SNAPSHOT_ENCRYPT_CHECK=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .Encrypted' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        if [[ ${AWS_S3_SNAPSHOT_ENCRYPT_CHECK} == "true" ]]
        then
          AWS_S3_SNAPSHOT_ENCRYPTKEY=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .KmsKeyId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        fi
        AWS_S3_SNAPSHOT_PROGRESS=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .Progress' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        AWS_S3_SNAPSHOT_CREATED=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .StartTime' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        AWS_S3_SNAPSHOT_CREATED_DATE=$(echo ${AWS_S3_SNAPSHOT_CREATED} | awk -FT '{print $1}')
        AWS_S3_SNAPSHOT_CREATED_TIME=$(echo ${AWS_S3_SNAPSHOT_CREATED} | awk -FT '{print $2}' | awk -F\. '{print $1}')
        AWS_S3_SNAPSHOT_VOLUME_ID=$(jq -r --arg aws_snapshot_id ${AWS_SNAPSHOT_ID} '.Snapshots[] | select(.SnapshotId == $aws_snapshot_id) | .VolumeId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json")
        if [ -z ${AMI_ID_SNAPSHOT} ]
        then
          inf "  S3 snapshot: ${BROWN}${AWS_SNAPSHOT_ID}${CYAN} from a volume: ${YELLOW}${VOLUME_ID}${CYAN} (created ${WINE}${AWS_S3_SNAPSHOT_CREATED_DATE} at ${AWS_S3_SNAPSHOT_CREATED_TIME}${CYAN})"
          if [[ ${AWS_S3_SNAPSHOT_ENCRYPT_CHECK} == "true" ]]
          then
            inf "    S3 snapshot: ${BROWN}${AWS_SNAPSHOT_ID}${CYAN} is encrypted with KeyID: ${LIGHT_BLUE}${AWS_S3_SNAPSHOT_ENCRYPTKEY}"
          fi
          if [[ ${CLEANING} == yes ]]
          then
            aws_snapshot_removal ${AWS_SNAPSHOT_ID}
          fi
        else
          if [[ ${AWS_S3_SNAPSHOT_ENCRYPT_CHECK} == "true" ]]
          then
            inf "  S3 snapshot: ${BROWN}${AWS_SNAPSHOT_ID}${CYAN} from a volume: ${YELLOW}${VOLUME_ID}${CYAN} which is an AMI: ${YELLOW}${AMI_ID_SNAPSHOT}${CYAN} (created ${WINE}${AWS_S3_SNAPSHOT_CREATED_DATE} at ${AWS_S3_SNAPSHOT_CREATED_TIME}${CYAN})"
            inf "    S3 snapshot: ${BROWN}${AWS_SNAPSHOT_ID}${CYAN} is encrypted with KeyID: ${LIGHT_BLUE}${AWS_S3_SNAPSHOT_ENCRYPTKEY}"
          fi
        fi
      ) &
    done
    wait
  fi
else
  warn "  There is no S3 snapshot(s)"
fi
end_time_collecting
SNAPSHOT_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  snapshots check time: ${ORANGE}${CONNECTIVITY_CHECK_TIME}"
fi
#AWS S3 snapshots

#AWS AMIs
start_time_collecting
inf ""
inf "${MAGENTA}EC2 AMIs"
if [ -s "${TMP}/${AWS_AMIS_DETAILS}_full.json" ] && [ ! -z $(jq -r '.Images[].ImageId' "${TMP}/${AWS_AMIS_DETAILS}_full.json" | head -n1) ]
then
  for AWS_AMI_IMAGE_ID in $(jq -r '.Images[] | .ImageId + " " + .Name' "${TMP}/${AWS_AMIS_DETAILS}_full.json" | grep "kpn_" | awk '{print $1}')
  do
    AWS_AMI_NAME=$(jq -r --arg image_id ${AWS_AMI_IMAGE_ID} '.Images[] | select(.ImageId == $image_id) | .Name' "${TMP}/${AWS_AMIS_DETAILS}_full.json")
    AWS_AMI_SNAPSHOT=$(jq -r --arg image_id ${AWS_AMI_IMAGE_ID} '.Images[] | select(.ImageId == $image_id) | .BlockDeviceMappings[].Ebs.SnapshotId' "${TMP}/${AWS_AMIS_DETAILS}_full.json")
    AWS_AMI_NAME_ENCRYPTED=$(jq -r --arg image_id ${AWS_AMI_IMAGE_ID} '.Images[] | select(.ImageId == $image_id) | .BlockDeviceMappings[].Ebs.Encrypted' "${TMP}/${AWS_AMIS_DETAILS}_full.json")
    if [[ ${AWS_AMI_NAME_ENCRYPTED} == true ]]
    then
      AWS_AMI_SNAPSHOT_KEYID=$(jq -r --arg snapshot_id ${AWS_AMI_SNAPSHOT} '.Snapshots[] | select(.SnapshotId == $snapshot_id) | .KmsKeyId' "${TMP}/${AWS_SNAPS_DETAILS}_full.json" | awk -F\/ '{print $NF}')
      AWS_AMI_SNAPSHOT_KEY_MANAGER=""
      if [[ ${AWS_KMS_CUSTOM_KEY_ID} == ${AWS_AMI_SNAPSHOT_KEYID} ]]
      then
        AWS_AMI_SNAPSHOT_KEY_MANAGER="CUSTOMER"
      fi
    fi
    AWS_AMI_DESCRIPTION=$(jq -r --arg image_id ${AWS_AMI_IMAGE_ID} '.Images[] | select(.ImageId == $image_id) | .Description' "${TMP}/${AWS_AMIS_DETAILS}_full.json")
    AWS_AMI_CREATION=$(jq -r --arg image_id ${AWS_AMI_IMAGE_ID} '.Images[] | select(.ImageId == $image_id) | .CreationDate' "${TMP}/${AWS_AMIS_DETAILS}_full.json")
    AWS_AMI_CDATE=$(echo ${AWS_AMI_CREATION} | awk -FT '{print $1}')
    AWS_AMIS_CTIME=$(echo ${AWS_AMI_CREATION} | awk -FT '{print $2}' | awk -F\. '{print $1}')
    AWS_AMI_CSECONDS=$(date -d"${AWS_AMI_CDATE}T${AWS_AMIS_CTIME}" +%s)
    AWS_AMI_SECONDS=$(echo "${NOW_SECONDS} - ${AWS_AMI_CSECONDS}" | bc)
    AWS_AMI_DAYS=$(echo "${AWS_AMI_SECONDS} / 3600 / 24" | bc)
    inf "  AMI id: ${YELLOW}${AWS_AMI_IMAGE_ID}"
    inf "    AMI name: ${BROWN}${AWS_AMI_NAME}${CYAN}, created: ${WINE}${AWS_AMI_CDATE} at ${AWS_AMIS_CTIME} ${CYAN}(${DARK_GREEN}${AWS_AMI_DESCRIPTION}${CYAN})"
    if [ ${AWS_AMI_SECONDS} -ge ${MONTH_SECONDS} ]
    then
      warn "     and is older then a ${RED}MONTH${WINE} (${RED}${AWS_AMI_DAYS}${WINE})"
    elif [ ${AWS_AMI_SECONDS} -ge ${WEEK_SECONDS} ]
    then
      inf "      and it is older then a ${WINE}WEEK${CYAN} (${WINE}${AWS_AMI_DAYS} days${CYAN})"
    elif [ ${AWS_AMI_SECONDS} -ge ${DAY_SECONDS} ]
    then
      inf "      and it is ${YELLOW}${AWS_AMI_DAYS}${CYAN} days old"
    fi
    inf "        AMI snapshot: ${BROWN}${AWS_AMI_SNAPSHOT}"
    if [[ ${AWS_AMI_NAME_ENCRYPTED} == true ]]
    then
      inf "          snapshot ${BROWN}${AWS_AMI_SNAPSHOT}${CYAN} (and AMI) is ${WINE}enrypted${CYAN} with such KeyId: ${LIGHT_BLUE}${AWS_AMI_SNAPSHOT_KEYID}"
      if [[ ${AWS_AMI_SNAPSHOT_KEY_MANAGER} == CUSTOMER ]]
      then
        inf "            Key: ${LIGHT_BLUE}${AWS_AMI_SNAPSHOT_KEYID}${CYAN} is appropriate ${WINE}customer${CYAN} managed key"
      else
        inf "            Key: ${LIGHT_BLUE}${AWS_AMI_SNAPSHOT_KEYID}${CYAN} is ${RED}NOT${CYAN} ${WINE}customer${CYAN} managed key, must be reencrypted with ${LIGHT_BLUE}${AWS_KMS_CUSTOM_KEY_ID}"
        aws_AMI_copy()
        {
          if [ $# -ne 2 ]
          then
            error "Function ${LIME}${FUNCNAME[0]}${RED} needs three parameters: ${YELLOW}(1)source-ami-id, (2)aws-kms-key-id"
            failed
          else
            SOURCE_AMI_ID=${1}
            KMS_KEY_ID=${2}
          fi
          #if name starts with "copied" and description has ami ID of ami which is just checked - not copying 
          #if [[ ${AWS_AMI_DESCRIPTION} =~ ^copied_from_${SOURCE_AMI_ID} ]]
          inf "  Copying source AMI id: ${YELLOW}${SOURCE_AMI_ID}${CYAN} to a new AMI, changing encryption to customer KEYID: ${LIGHT_BLUE}${KMS_KEY_ID}"
          aws ${AWS_PROFILE_USE_CHECK[*]} ec2 copy-image --encrypted --kms-key-id ${KMS_KEY_ID} --source-region ${AWS_REGION} --source-image-id ${SOURCE_AMI_ID} --description "copied_from_${SOURCE_AMI_ID}_${AWS_AMI_DESCRIPTION}" --name "copied_${AWS_AMI_NAME}" > "${TMP}/${AWS_AMIS_DETAILS}_${SOURCE_AMI_ID}_copy_full.json" 2>"${LOG}/${AWS_AMIS_DETAILS}_${SOURCE_AMI_ID}_copy.log"
          DESTINATION_AMI_ID=$(jq -r '.ImageId' "${TMP}/${AWS_AMIS_DETAILS}_${AWS_AMI_IMAGE_ID}_copy_full.json")
          inf "    New AMI id: ${YELLOW}${DESTINATION_AMI_ID}"
          while [[ $(aws ${AWS_PROFILE_USE_CHECK[*]} ec2 describe-images --image-ids  ${DESTINATION_AMI_ID} | jq -r '.Images[].State') == "pending" ]]
          do
            for NUMBER in {1..100}
            do
              sleep 3
              ProgressBar ${NUMBER} 100
            done
            printf '\n'
          done
          inf "    Image: ${BROWN}${DESTINATION_AMI_ID}${WINE} is ${GREEN}available${CYAN}..."
          if [[ ${AWS_OWNER_ID} == "623623120519" ]]
          then
            aws ${AWS_PROFILE_USE_CHECK[*]} ec2 modify-image-attribute --image-id ${DESTINATION_AMI_ID} --launch-permission "Add=[{UserId=365117780834}]"
            #error handling
          elif [[ ${AWS_OWNER_ID} == "365117780834" ]]
          then
            aws ${AWS_PROFILE_USE_CHECK[*]} ec2 modify-image-attribute --image-id ${DESTINATION_AMI_ID} --launch-permission "Add=[{UserId=623623120519}]"
            #error handling
          fi
        }
        #aws_AMI_copy ${AWS_AMI_IMAGE_ID} ${AWS_KMS_CUSTOM_KEY_ID}
      fi
    fi
    echo "
              {
                  \\\"value\\\": \\\"${AWS_AMI_IMAGE_ID}\\\",
                  \\\"short\\\": true
              },
              {
                  \\\"value\\\": \\\"${AWS_AMI_SNAPSHOT}\\\",
                  \\\"short\\\": true
              },
            " >> "${TMP}/${AWS_AMIS_DETAILS}_slack.out"
  done
  aws ${AWS_PROFILE_USE_CHECK[*]} ec2 describe-images --owners "${AWS_OWNER_ID}" > "${TMP}/${AWS_AMIS_DETAILS}_full.json" 2>"${LOG}/${AWS_AMIS_DETAILS}.log"
  aws_newest_ami
else
  warn "  There is no EC2 AMIs"
fi
end_time_collecting
AMI_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  AMIs check time: ${ORANGE}${CONNECTIVITY_CHECK_TIME}"
fi
#AWS AMIs

#AWS S3 buckets
start_time_collecting
if [ -s "${TMP}/${AWS_S3BUCKETS_DETAILS}_full.output" ]
then
  inf ""
  S3_BUCKETS_AMOUNT=$(wc -l "${TMP}/${AWS_S3BUCKETS_DETAILS}_full.output" | awk '{print $1}')
  inf "${MAGENTA}S3 buckets (${YELLOW}${S3_BUCKETS_AMOUNT} buckets${MAGENTA})"
  for S3_BUCKET in $(awk '{print $NF}' "${TMP}/${AWS_S3BUCKETS_DETAILS}_full.output")
  do
    (
      inf "  S3 bucket: ${YELLOW}${S3_BUCKET}${CYAN} exists"
      aws_S3_bucket_secure_access_policy "${S3_BUCKET}"
      aws_S3_bucket_encryption "${S3_BUCKET}"
      aws_S3_bucket_lifecycle "${S3_BUCKET}"
      aws_S3_bucket_logging "${S3_BUCKET}"
      if [[ ${AWS_ZONE} == "Y" ]]
      then
        inf "    Mounting locally S3 buckets"
        #for BUCKET in ${AWS_S3_BUCKETS[*]}
        #do 
          S3_BUCKET_MOUNT_CHECK=$(mount  | grep s3fs | grep -w ${S3_BUCKET} | awk '{print $3}')
          if [ -z ${S3_BUCKET_MOUNT_CHECK} ]
          then
            sudo mkdir -p /media/${S3_BUCKET}
            sudo s3fs ${S3_BUCKET} /media/${S3_BUCKET} -o iam_role=${CHECKED_INSTANCE_PROFILE_ROLE},allow_other,use_cache=/tmp/cache,default_acl=public-read,uid=30006,gid=30006
          else
            inf "      Bucket: ${YELLOW}${S3_BUCKET}${CYAN} is already mounted"
          fi
        #done
      fi
    ) &
  done
fi
wait
end_time_collecting
BUCKET_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  buckets checking runtime: ${ORANGE}${BUCKET_CHECK_TIME}"
fi
#AWS S3 buckets

#AWS EventBridge
start_time_collecting
inf ""
inf "${MAGENTA}Event Buses"
if [ -s "${TMP}/${AWS_EVENTS_BUSES}_full.json" ] 
then
  for EVENT_BUS in $(jq -r '.EventBuses[].Name' "${TMP}/${AWS_EVENTS_BUSES}_full.json")
  do
    EVENT_BUS_NAME=${EVENT_BUS}
    EVENT_BUS_ARN="$(jq -r --arg event_bus_name ${EVENT_BUS_NAME} '.EventBuses[] | select(.Name == $event_bus_name) | .Arn' "${TMP}/${AWS_EVENTS_BUSES}_full.json")"
    inf "  Event bus: ${DARK_GREEN}${EVENT_BUS_NAME}"
    if [ -s "${TMP}/${AWS_EVENTS_RULES}_full.json" ] && [ ! -z $(jq -r --arg aws_default_name ${AWS_DEFAULT_NAME} --arg event_bus_name ${EVENT_BUS_NAME} '.Rules[] | select(.Name | contains($aws_default_name) | not) | select(.EventBusName == $event_bus_name) | select(.ManagedBy == "schemas.amazonaws.com" | not) | .Name' "${TMP}/${AWS_EVENTS_RULES}_full.json" | head -n1) ]
    then
      for EVENT_RULE in $(jq -r --arg aws_default_name ${AWS_DEFAULT_NAME} --arg event_bus_name ${EVENT_BUS_NAME} '.Rules[] | select(.Name | contains($aws_default_name) | not) | select(.EventBusName == $event_bus_name) | select(.ManagedBy == "schemas.amazonaws.com" | not) | .Name' "${TMP}/${AWS_EVENTS_RULES}_full.json")
      do
        #aws ${AWS_PROFILE_USE_CHECK[*]} events list-targets-by-rule --event-bus-name ${EVENT_BUS_NAME} --rule ${EVENT_RULE} > "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json" 2>&1
        EVENT_RULE_NAME=${EVENT_RULE}
        EVENT_RULE_BUS=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .EventBusName' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        EVENT_RULE_SCHEDULE=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .ScheduleExpression' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        EVENT_RULE_ARN=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .Arn' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        EVENT_RULE_STATE=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .State' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        EVENT_RULE_DESCRIPTION=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .Description' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        inf "    Event rule: ${LIME}${EVENT_RULE_NAME}${CYAN}, of this bus: ${DARK_GREEN}${EVENT_BUS_NAME}${CYAN}, scheduled on: ${BROWN}\"${EVENT_RULE_SCHEDULE}\""
        if [ -s "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json" ] && [ ! -z $(jq -r '.Targets[].Arn' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json" | head -n1) ]
        then
          for EVENT_TARGET_ARN in $(jq -r '.Targets[].Arn' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json" | sort -u)
          do
            (
            for EVENT_TARGET_ID in $(jq -r --arg event_target_arn ${EVENT_TARGET_ARN} '.Targets[] | select(.Arn == $event_target_arn) | .Id' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json")
            do
              inf "      to target Arn: ${GREEN}${EVENT_TARGET_ARN}"
              EVENT_TARGET_NAME=$(echo ${EVENT_TARGET_ARN} | awk -F\: '{print $NF}')
              EVENT_EVENT_NAME=$(echo ${EVENT_RULE} | sed 's/_rule/_event/g')
              if [[ ${CLEANING} == no ]] && [[ ${XTRA_CLEANING} == no ]]
              then
                if [ -s "${TMP}/${AWS_EVENTS_RULES}_${EVENT_EVENT_NAME}_trust_full.json" ]
                then
                  LAMBDA_FUNCTION_ARN_FROM_EVENT=$(jq -r '.Statement[].Resource' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_EVENT_NAME}_trust_full.json")
                  SID_FROM_EVENT=$(jq -r '.Statement[].Sid' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_EVENT_NAME}_trust_full.json")
                  EVENT_BRIDGE_RULE_ARN=$(jq -r '.Statement[].Condition.ArnLike."AWS:SourceArn"' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_EVENT_NAME}_trust_full.json")
                  PERMISSION_EVENTBRIDGE_LAMBDA=$(jq -r '.Statement[].Action' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_EVENT_NAME}_trust_full.json")
                  PERMISSIONS_ACTION="lambda:InvokeFunction"
                  if [[ ${PERMISSIONS_ACTION} == ${PERMISSION_EVENTBRIDGE_LAMBDA} ]]
                  then
                    if [[ ${VERBOSE} == yes ]]
                    then
                      debug "        Appropriate permissions and trust to: ${DARK_GREEN}${SID_FROM_EVENT}${BLUE} are set properly already"
                    fi
                  else
                    warn "        ${RED}Trust has been set but with different permissions... it might not work finally"
                  fi
                fi
              fi
              if [[ ${CLEANING} == yes ]] && [[ ${XTRA_CLEANING} == yes ]]
              then
                event_bridge_remove_target ${EVENT_TARGET_ID} ${EVENT_RULE_NAME}
              fi
            done
            ) &
          done
          wait
        else
          warn "      There is no EventTargets related to rule: ${LIME}${EVENT_RULE_NAME}"
          if [[ ${CLEANING} == yes ]]
          then
            event_bridge_remove_rule ${EVENT_RULE_NAME}
          fi
        fi
        if [[ ${CLEANING} == yes ]] && [[ ${XTRA_CLEANING} == yes ]]
        then
          event_bridge_remove_rule ${EVENT_RULE_NAME}
        fi
      done
    else
      warn "    There is no ${AWS_COMMON_NAME} EventRules related to the bus: ${DARK_GREEN}${EVENT_BUS_NAME}"
    fi
    if [[ ${CLEANING} == yes ]] && [[ ${XTRA_CLEANING} == yes ]] && [[ ${EVENT_BUS_NAME} != "default" ]]
    then
      inf "      Removing bus: ${DARK_GREEN}${EVENT_BUS_NAME}"
      aws ${AWS_PROFILE_USE_CHECK[*]} events delete-event-bus --name ${EVENT_BUS}
    fi
  done
else
  warn "  There is no ${AWS_COMMON_NAME} Event Buses yet"  
fi
end_time_collecting
EVENTBRIDGE_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  events collecting information runtime: ${ORANGE}${EVENTBRIDGE_CHECK_TIME}"
fi
#AWS events

#AWS SNS
#ToDo: AWS SNS list of topics, subscriptions, endpoints list and clears
if [ -s "${TMP}/${AWS_SNS_TOPICS}_full.json" ]
then
  inf ""
  inf "${MAGENTA}SNS topics:"
  TOPIC_ARN_CHECK=$(jq -r --arg default_name ${AWS_DEFAULT_NAME} '.Topics[] | select(.TopicArn | contains($default_name) | not) | .TopicArn' "${TMP}/${AWS_SNS_TOPICS}_full.json" | head -n1)
  if [ -z ${TOPIC_ARN_CHECK} ]
  then
    warn "  There is no SNS topics yet"
  else
    for TOPIC_ARN in $(jq -r --arg default_name ${AWS_DEFAULT_NAME} '.Topics[] | select(.TopicArn | contains($default_name) | not) | .TopicArn' "${TMP}/${AWS_SNS_TOPICS}_full.json")
    do
      inf "  Topic ARN: ${LIGHT_BLUE}${TOPIC_ARN}"
      if [ -s "${TMP}/${AWS_SNS_SUBSC}_full.json" ]
      then
        for SUBSCRIPTION_ARN in $(jq -r --arg topic_arn ${TOPIC_ARN} '.Subscriptions[] | select(.TopicArn == $topic_arn) | .SubscriptionArn' "${TMP}/${AWS_SNS_SUBSC}_full.json")
        do
          inf "    with subscription: ${BROWN}${SUBSCRIPTION_ARN}"
        done
        #ToDo: is topic encrypted ?
        TOPIC_ARN_ENCRYPTED_CHECK=$(aws ${AWS_PROFILE_USE_CHECK[*]} sns get-topic-attributes --topic-arn "${TOPIC_ARN}" | jq -r '.Attributes.KmsMasterKeyId')
        if [ ! -z ${TOPIC_ARN_ENCRYPTED_CHECK} ]
        then
          inf "      and it is encrypted with: ${LIGHT_BLUE}${TOPIC_ARN_ENCRYPTED_CHECK}"
        else
          warn "      and it should be encrypted"
          #aws ${AWS_PROFILE_USE_CHECK[*]} sns set-topic-attributes --topic-arn "${TOPIC_ARN}" --attribute-name KmsMasterKeyId --attribute-value "${SNS_KEY_ID}"
        fi
      fi
    done
  fi
fi
#aws lambda add-permission --function-name SNS-X-Account \
#topic: --source-arn arn:aws:sns:us-east-2:12345678901A:lambda-x-account \
#lambda function name:  --statement-id sns-x-account --action "lambda:InvokeFunction" \
#--principal sns.amazonaws.com --profile accountB
#jq '.Subscriptions[]' "${TMP}/${AWS_SNS_TOPICS}_full.json"
#SubscriptionArn": "arn:aws:sns:eu-west-1:623623120519:kpn-account-events:9d85106d-a9a5-4f43-8dd7-a5d612363818",
#Owner": "623623120519",
#Protocol: http, https, email, email-json, sms, sqs, application, lambda
#Endpoint": "
#TopicArn
#jq '.Topics[]' "${TMP}/${AWS_SNS_SUBSC}_full.json"
#TopicArn
#AWS SNS

#AWS KeyPairs
start_time_collecting
if [ -s "${TMP}/${AWS_EC2_KEYPAIRS}_full.json" ]
then
  inf ""
  inf "${MAGENTA}EC2 KeyPairs:"
  AWS_EC2_KEYFINGERPRINT_CHECK=$(jq -r '.KeyPairs[].KeyFingerprint' "${TMP}/${AWS_EC2_KEYPAIRS}_full.json" | head -n1)
  if [ ! -z ${AWS_EC2_KEYFINGERPRINT_CHECK} ]
  then
    for AWS_EC2_KEYFINGERPRINT in $(jq -r '.KeyPairs[].KeyFingerprint' "${TMP}/${AWS_EC2_KEYPAIRS}_full.json")
    do
      for KEY_NAME in $(jq -r --arg fingerprint ${AWS_EC2_KEYFINGERPRINT} '.KeyPairs[] | select(.KeyFingerprint == $fingerprint) | .KeyName' "${TMP}/${AWS_EC2_KEYPAIRS}_full.json")
      do
        KEY_PAIR_ID=$(jq -r --arg keyname ${KEY_NAME} '.KeyPairs[] | select(.KeyName == $keyname) | .KeyPairId' "${TMP}/${AWS_EC2_KEYPAIRS}_full.json")
        inf "  KeyName: ${POWDER_BLUE}${KEY_NAME}${CYAN}, with KeyPairId: ${LIME}${KEY_PAIR_ID}"
        if [[ ${CLEANING} == yes ]] && [[ ${XTRA_CLEANING} == yes ]] && [[ ${AWS_ZONE} == "N" ]]
        then
          aws_key_removal ${KEY_PAIR_ID}
        fi
      done
    done
  else
    warn "  There is no KeyPairs" 
  fi
fi
#AWS KeyPairs
end_time_collecting
KEYPAIRS_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  KEY PAIRs check time: ${ORANGE}${CONNECTIVITY_CHECK_TIME}"
fi
#AWS KeyPairs

#AWS KMS
start_time_collecting
if [ -s "${TMP}/${AWS_KMS_ALIASES}_full.json" ]
then
  inf ""
  inf "${MAGENTA}KMS Keys:"
  for TARGET_KEY_ID in $(jq -r '.Aliases[] | .TargetKeyId' "${TMP}/${AWS_KMS_ALIASES}_full.json")
  do
    (
      if [[ ${TARGET_KEY_ID} != "null" ]] || [ -z ${TARGET_KEY_ID} ]
      then
        TARGET_KEY_ALIAS_NAME=$(jq -r --arg target_key_id ${TARGET_KEY_ID} '.Aliases[] | select(.TargetKeyId == $target_key_id) |.AliasName' "${TMP}/${AWS_KMS_ALIASES}_full.json")
        inf "  KMS KeyID: ${LIGHT_BLUE}${TARGET_KEY_ID}${CYAN}, with an KeyAlias: ${BROWN}${TARGET_KEY_ALIAS_NAME}"
      fi
    ) &
  done
fi
wait
end_time_collecting
KMS_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  KMS check time: ${ORANGE}${CONNECTIVITY_CHECK_TIME}"
fi
#AWS KMS

#AWS Roles and policies
start_time_collecting
if [ -s "${TMP}/${AWS_POLICIES}_${AWS_NAMES_PREFIX}_full.json" ]
then
  inf ""
  inf "${MAGENTA}IAM policy:"
  AWS_IAM_POLICY_NAME_CHECK=$(jq -r --arg owner_id ${AWS_OWNER_ID} --arg aws_default_name ${AWS_DEFAULT_NAME} '.Policies[] | select(.Arn | contains($owner_id)) | select(.PolicyName | startswith($aws_default_name) | not)' "${TMP}/${AWS_POLICIES}_full.json" | head -n1)
  if [ ! -z ${AWS_IAM_POLICY_NAME_CHECK} ]
  then
    for AWS_IAM_POLICY_NAME in $(jq -r --arg owner_id ${AWS_OWNER_ID} --arg aws_default_name ${AWS_DEFAULT_NAME} '.Policies[] | select(.Arn | contains($owner_id)) | select(.PolicyName | startswith($aws_default_name) | not) | .PolicyName' "${TMP}/${AWS_POLICIES}_full.json")
    do
      (
      AWS_IAM_POLICY_ARN="$(jq -r --arg aws_iam_policy_name ${AWS_IAM_POLICY_NAME} '.Policies[] | select(.PolicyName == $aws_iam_policy_name) | .Arn' "${TMP}/${AWS_POLICIES}_full.json")"
      AWS_IAM_POLICY_ID=$(jq -r --arg aws_iam_policy_name ${AWS_IAM_POLICY_NAME} '.Policies[] | select(.PolicyName == $aws_iam_policy_name) | .PolicyId' "${TMP}/${AWS_POLICIES}_full.json")
      inf "  Policy: ${YELLOW}${AWS_IAM_POLICY_NAME}${CYAN}, with ARN: ${LIME}${AWS_IAM_POLICY_ARN}${CYAN} exists"
      AWS_IAM_POLICY_ROLENAME_CHECK=$(aws_list-entities-for-policy "${AWS_IAM_POLICY_ARN}" && jq -r '.PolicyRoles[].RoleName' ${TMP}/${AWS_POLICY_ENTITIES}_${AWS_IAM_POLICY_NAME}_full.json | head -n1)
      if [ -z ${AWS_IAM_POLICY_NAME_CHECK} ]
      then
        inf "    and it is not attached to any role"
        if [[ ${CLEANING} == yes ]] && [[ ${XTRA_CLEANING} == yes ]]
        then
          aws_policy_removal "${AWS_IAM_POLICY_ARN}"
        fi
      else
        for AWS_IAM_ROLENAME in $(jq -r '.PolicyRoles[].RoleName' ${TMP}/${AWS_POLICY_ENTITIES}_${AWS_IAM_POLICY_NAME}_full.json)
        do
          inf "    Policy: ${YELLOW}${AWS_IAM_POLICY_NAME}${CYAN} is attached to the role: ${YELLOW}${AWS_IAM_ROLENAME}"
          if [[ ${CLEANING} == yes ]] && [[ ${XTRA_CLEANING} == yes ]] && [[ ${AWS_ZONE} == "N" ]]
          then
            aws_detaching_policy_from_role ${AWS_IAM_ROLENAME} "${AWS_IAM_POLICY_ARN}"
            aws_policy_removal "${AWS_IAM_POLICY_ARN}"
            inf "      ${MAGENTA}Checking if role: ${YELLOW}${AWS_IAM_ROLENAME}${MAGENTA} is added to any instance profile..."
            INSTANCE_PROFILE_ROLE_NAME=$(aws_list-instance-profiles-for-role "${AWS_IAM_ROLENAME}" && jq -r '.InstanceProfiles[].InstanceProfileName' "${TMP}/${AWS_INSTANCE_PROFILES}_${AWS_IAM_ROLENAME}_full.json")
            if [ -z ${INSTANCE_PROFILE_ROLE_NAME} ]
            then
              aws_role_removal "${AWS_IAM_ROLENAME}"
            else
              aws_removing_role_from_instance_profile "${AWS_IAM_ROLENAME}" "${INSTANCE_PROFILE_ROLE_NAME}"
              aws_role_removal "${AWS_IAM_ROLENAME}"
              aws_instance-profile_removal "${INSTANCE_PROFILE_ROLE_NAME}"
            fi
          fi
        done
      fi
      ) &
    done
  else
    warn "  There is no IAM policy"
  fi
fi
wait
end_time_collecting
POLICIES_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  policies check time: ${ORANGE}${POLICIES_CHECK_TIME}"
fi
#AWS Roles and policies

#AWS Roles
start_time_collecting
aws_list-roles
end_time_collecting
ROLES_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  roles check time: ${ORANGE}${ROLES_CHECK_TIME}"
fi
#AWS Roles

#AWS instance profiles
start_time_collecting
aws_list-profiles
end_time_collecting
PROFILES_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  instance profiles check time: ${ORANGE}${PROFILES_CHECK_TIME}"
fi
#AWS instance profiles

#AWS security groups
start_time_collecting
aws_list-securitygroups
end_time_collecting
SEC_GROUPS_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  security groups check time: ${ORANGE}${SEC_GROUPS_CHECK_TIME}"
fi
#AWS security groups

#AWS Lambda functions
start_time_collecting
if [ -s "${TMP}/${AWS_LAMBDA_FUNCTIONS}_full.json" ]
then
  inf ""
  if [[ ${CLEANING} == no ]] && [[ ${XTRA_CLEANING} == no ]]
  then
    aws_key_create
  fi
  PERMISSIONS_BOUNDARY_ARN="$(jq -r '.Policies[] | select(.PolicyName | contains("-permissions-boundary")) | .Arn' "${TMP}/${AWS_POLICIES}_full.json")"
  aws_default_subnet
  inf "${MAGENTA}Lambda functions:"
  AWS_LAMBDA_FUNCTION_NAMES=$(jq -r --arg aws_default_name ${AWS_DEFAULT_NAME} '.Functions[] | select(.FunctionName | startswith($aws_default_name) | not) | .FunctionName' "${TMP}/${AWS_LAMBDA_FUNCTIONS}_full.json" | head -n1)
  if [ -z ${AWS_LAMBDA_FUNCTION_NAMES} ]
  then
    warn "  There is no Lambda function(s) created"
  else
    for AWS_LAMBDA_FUNCTION_NAME in $(jq -r --arg aws_default_name ${AWS_DEFAULT_NAME} '.Functions[] | select(.FunctionName | startswith($aws_default_name) | not) | .FunctionName' "${TMP}/${AWS_LAMBDA_FUNCTIONS}_full.json")
    do
      SECURITY_GROUP_ID=$(jq -r --arg security_group_name ${SECURITY_GROUP_LAMBDA_NAME} '.SecurityGroups[] | select(.GroupName == $security_group_name) | .GroupId' "${TMP}/${AWS_SECURITY_GROUPS}_full.json")
      (
        inf "  Lambda function: ${YELLOW}${AWS_LAMBDA_FUNCTION_NAME}"
        if [[ ! -z ${AMI_TOBE_REMOVED} ]] && [[ ${CLEANING} == yes ]] && [[ ${XTRA_CLEANING} == no ]]
        then
          lambda_function_update ${AWS_LAMBDA_FUNCTION_NAME}
        elif [[ ${CLEANING} == yes ]] && [[ ${XTRA_CLEANING} == yes ]]
        then
          inf "    removing Lambda function: ${YELLOW}${AWS_LAMBDA_FUNCTION_NAME}"
          aws ${AWS_PROFILE_USE_CHECK[*]} lambda delete-function --function-name ${AWS_LAMBDA_FUNCTION_NAME}
          #ToDo: migrate removing lambda to function + error handling
        fi
      ) &
    done
  fi
fi
wait
end_time_collecting
LAMBDA_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  Lambda functions check time: ${ORANGE}${LAMBDA_CHECK_TIME}"
fi
#AWS Lambda functions

#AWS logs
start_time_collecting
if [ -s "${TMP}/${AWS_LOGS}_full.json" ]
then
  inf ""
  inf "${MAGENTA}Log groups"
  AWS_LOG_GROUPS=$(jq -r '.logGroups[].logGroupName' "${TMP}/${AWS_LOGS}_full.json" | head -n1)
  if [ -z ${AWS_LOG_GROUPS} ]
  then
    warn "  There is no log group(s) created yet"
  else
    inf "  Log group:"
    inf "    Rentention policy to log group:"
    for AWS_LOG_NAME in $(jq -r '.logGroups[].logGroupName' "${TMP}/${AWS_LOGS}_full.json")
    do
      (
        AWS_LOGS_NAME=$(echo ${AWS_LOG_NAME} | awk -F\/ '{print $NF}')
        RETENTION_LOGS_CHECKING=$(jq -r --arg aws_log_name ${AWS_LOG_NAME} '.logGroups[] | select(.logGroupName == $aws_log_name) | .retentionInDays' "${TMP}/${AWS_LOGS}_full.json")
        if [[ ${RETENTION_LOGS_CHECKING} == null ]] || [ -z ${RETENTION_LOGS_CHECKING} ] || [ ${RETENTION_LOGS_CHECKING} -ne ${AWS_LOGS_RETENTION_DAYS} ]
        then
          inf "      ${BROWN}${AWS_LOG_NAME}${CYAN} for ${LIGHT_BLUE}${AWS_LOGS_RETENTION_DAYS}${CYAN} days ${WINE}must${CYAN} be applied"
          aws ${AWS_PROFILE_USE_CHECK[*]} logs put-retention-policy --log-group-name ${AWS_LOG_NAME} --retention-in-days ${AWS_LOGS_RETENTION_DAYS} > "${TMP}/${AWS_LOGS}_${AWS_LOGS_NAME}_group_retention.json" 2> "${LOG}/${AWS_LOGS}_${AWS_LOGS_NAME}_group_retention.log"
          ERROR_CODE="$?"
          if [ ${ERROR_CODE} -eq 0 ]
          then
            debug "        Rentention policy ${LIGHT_BLUE}${AWS_LOGS_RETENTION_DAYS}${BLUE} days applied properly (to log group: ${BROWN}${AWS_LOG_NAME}"
          else
            error "        Rentention policy ${LIGHT_BLUE}${AWS_LOGS_RETENTION_DAYS}${RED} cannot be applied"
            debug "          LOG_FILE=${LOG}/${AWS_LOGS}_${AWS_LOGS_NAME}_group_retention.log"
            error "            $(cat "${LOG}/${AWS_LOGS}_${AWS_LOGS_NAME}_group_retention.log")"
          fi
        else
          inf "      ${BROWN}${AWS_LOG_NAME}${CYAN} for ${LIGHT_BLUE}${AWS_LOGS_RETENTION_DAYS}${CYAN} days is already ${GREEN}applied"
        fi
        if [[ ${CLEANING} == yes ]]
        then
          inf "    removing log group: ${BROWN}${AWS_LOG_NAME}"
          aws ${AWS_PROFILE_USE_CHECK[*]} logs delete-log-group --log-group-name ${AWS_LOG_NAME} > "${TMP}/${AWS_LOGS}_${AWS_LOGS_NAME}_group_deletion.json" 2> "${LOG}/${AWS_LOGS}_${AWS_LOGS_NAME}_group_deletion.log"
        fi
      ) &
    #ToDo: logs from CloudWatch
    #aws ${AWS_PROFILE_USE_CHECK[*]} logs get-log-events --log-group-name /aws/lambda/${AWS_LAMBDA_NAME} --log-stream-name $(cat out) --limit 5
    done
  fi
fi
wait 
#aws ${AWS_PROFILE_USE_CHECK[*]} logs describe-log-streams --log-group-name "/aws/lambda/${AWS_LAMBDA_FUNCTION_NAME}"
#aws ${AWS_PROFILE_USE_CHECK[*]} logs delete-log-stream --log-group-name --log-stream-name
end_time_collecting
LOGS_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  CloudWatch logs check time: ${ORANGE}${LOGS_CHECK_TIME}"
fi
#AWS logs

#AWS CloudTrial
if [ -s "${TMP}/${AWS_TRAILS}_full.json" ]
then
  inf ""
  inf "${MAGENTA}CloudTrails activity:"
  AWS_TRAILS_LIST=$(jq -r --arg aws_default_name ${AWS_DEFAULT_NAME} '.trailList[] | select(.Name == $aws_default_name) | not' "${TMP}/${AWS_TRAILS}_full.json" | head -n1)
  if [ -z ${AWS_TRAILS_LIST} ]
  then
    warn "  There is no trails set yet"
  else
    for AWS_TRAIL_NAME in $(jq -r --arg aws_default_name ${AWS_DEFAULT_NAME} '.trailList[] | select(.Name == $aws_default_name) | not' "${TMP}/${AWS_TRAILS}_full.json")
    do
      inf "  Trail name: ${GREEN}${AWS_TRAIL_NAME}"
    done
  fi
fi
#AWS CloudTrial

#AWS compliance
#checking what is not compliant
#jq '.ComplianceByConfigRules[] | select((.Compliance.ComplianceType != "INSUFFICIENT_DATA") and (.Compliance.ComplianceType != "COMPLIANT"))' aws_compliance_2020.10.14-14.14.04_full.json
#AWS compliance

#AWS costs:
start_time_collecting
inf ""
if grep -q "AccessDeniedException" "${TMP}/${AWS_COSTS_DETAILS}_full.json"
then
  warn "${MAGENTA}Costs${WINE} are not available due to ${RED}AccessDeniedException"
else
  inf "${MAGENTA}Costs:"
  inf "  current month (${BROWN}${CURRENT_MONTH}${CYAN}): ${LIGHT_YELLOW}${CURRENT_MONTH_COSTS} USD"
  if [[ ${VERBOSE} == "yes" ]]
  then
    IFS=${NEWIFS}
    inf "    per services:"
    for AWS_SERVICE_COST_LINE in $(jq -r '.ResultsByTime[].Groups[] | .Keys[] + "~" + .Metrics.NetAmortizedCost.Amount' "${TMP}/${AWS_COSTS_DETAILS}_current_month_full.json" | grep -v "~0.00" | grep -v "~0$")
    do
      AWS_SERVICE=$(echo ${AWS_SERVICE_COST_LINE} | awk -F\~ '{printf "%-40s", $1}')
      AWS_SERVICE_COSTS=$(echo ${AWS_SERVICE_COST_LINE} | awk -F\~ '{print $2}')
      debug "      ${MAGENTA}${AWS_SERVICE}${BLUE}- ${LIGHT_YELLOW}${AWS_SERVICE_COSTS} USD"
    done
    IFS=${ORIGIFS}
  fi
  inf "  current year (${BROWN}${CURRENT_YEAR}${CYAN}): ${LIGHT_YELLOW}${CURRENT_YEAR_COSTS} USD"
fi
wait
end_time_collecting
COSTS_CHECK_TIME=${RUNTIME}
if [[ ${VERBOSE} == yes ]]
then
  debug "  costs check time: ${ORANGE}${COSTS_CHECK_TIME}"
fi
#AWS costs:

#Slack notifications
if [[ ${CLEANING} == no ]]
then
  if [[ ${VERBOSE} == no ]]
  then
    debug ""
    debug "  Slack notification...."
    export SLACK_INSTANCES=$(cat "${TMP}/${AWS_INSTANCES_DETAILS}_slack.out")
    export SLACK_AMIS=$(cat "${TMP}/${AWS_AMIS_DETAILS}_slack.out")
    export SLACK_VOLS=$(cat "${TMP}/${AWS_VOLS_DETAILS}_slack.out")
    source "${SCRIPTS_HOME}/slack_notification_info"
    debug "    has just been sent"
  fi
fi

END_AWS_TIME=$(date +%s.%4N)
IFS=${ORIGIFS}
if [[ ${VERBOSE} == no ]]
then
  log_tmp_maintenance
fi

AWS_TEST_RUNTIME=$(echo "scale=4; x=(${END_AWS_TIME} - ${START_AWS_TIME}); if(x<1) print 0; x" | bc)
inf "AWS test script has taken: ${WINE}${AWS_TEST_RUNTIME}${CYAN} [s]"
inf "  collecting data time from AWS has taken: ${WINE}${AWS_COLLECTING_TIME}${CYAN} [s]"
