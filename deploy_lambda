#!/usr/bin/env bash

#AWS IAM LAMBDA: role
if [ -s "${TMP}/${AWS_ROLES}_full.json" ]
then
  inf ""
  inf "${MAGENTA}Checking if appropriate role (${YELLOW}${AWS_EC2_LAMBDA_ROLE}${MAGENTA}) for LAMBDA service exists"
  AWS_EC2_LAMBDA_ROLE_CHECK=$(jq -r --arg ec2_lambda_role ${AWS_EC2_LAMBDA_ROLE} '.Roles[] | select(.RoleName == $ec2_lambda_role) | .RoleName' "${TMP}/${AWS_ROLES}_full.json")
  if [ ! -z ${AWS_EC2_LAMBDA_ROLE_CHECK} ]
  then
    inf "  Role ${YELLOW}${AWS_EC2_LAMBDA_ROLE}${CYAN} exists"
    export EC2_LAMBDA_ROLE_ARN=$(jq -r --arg ec2_lambda_role ${AWS_EC2_LAMBDA_ROLE} '.Roles[] | select(.RoleName == $ec2_lambda_role) | .Arn' "${TMP}/${AWS_ROLES}_full.json")
  else
    warn "  Role ${YELLOW}${AWS_EC2_LAMBDA_ROLE}${WINE} doesn't exist"
    aws_role_create ${AWS_EC2_LAMBDA_ROLE} lambda
  fi
fi
#AWS IAM LAMBDA: roles

#AWS IAM LAMBDA: policy
if [ -s "${TMP}/${AWS_POLICIES}_${AWS_NAMES_PREFIX}_full.json" ]
then
  inf ""
  inf "${MAGENTA}Checking if appropriate policy (${DARK_GREEN}${AWS_EC2_LAMBDA_POLICY}${MAGENTA}) for LAMBDA service exists"
  NAMED_POLICY_ARN=$(jq -r --arg prefixed_policy_name ${AWS_EC2_LAMBDA_POLICY} 'select(.PolicyName == $prefixed_policy_name) | .Arn' "${TMP}/${AWS_POLICIES}_${AWS_NAMES_PREFIX}_full.json")
  if [ -z ${NAMED_POLICY_ARN} ]
  then
    warn "  Policy ${DARK_GREEN}${AWS_EC2_LAMBDA_POLICY}${WINE} doesn't exist"
    aws_lambda_policy_create ${AWS_EC2_LAMBDA_POLICY}
    NAMED_POLICY_ARN="$(jq -r '.Policy.Arn' "${TMP}/${AWS_POLICIES}_${AWS_EC2_LAMBDA_POLICY}_creation.json")"
    aws_attaching_policy_to_role ${AWS_EC2_LAMBDA_ROLE} "${NAMED_POLICY_ARN}"
  else
    inf "  Policy ${DARK_GREEN}${AWS_EC2_LAMBDA_POLICY}${CYAN} exists"
    NAMED_ROLE_NAME=$(aws ${AWS_PROFILE_USE_CHECK[*]} iam list-entities-for-policy --policy-arn "${NAMED_POLICY_ARN}" | jq -r '.PolicyRoles[].RoleName' | grep ${AWS_EC2_LAMBDA_ROLE})
    if [ -z ${NAMED_ROLE_NAME} ]
    then
      aws_attaching_policy_to_role ${AWS_EC2_LAMBDA_ROLE} "${NAMED_POLICY_ARN}"
    else
      inf "    Policy: ${DARK_GREEN}${AWS_EC2_LAMBDA_POLICY}${CYAN} is already attached to role: ${YELLOW}${AWS_EC2_LAMBDA_ROLE}"
    fi
  fi
else
  warn "  Policy ${DARK_GREEN}${AWS_EC2_LAMBDA_POLICY}${WINE} doesn't exist"
  aws_lambda_policy_create ${AWS_EC2_LAMBDA_POLICY}
  NAMED_POLICY_ARN="$(jq -r '.Policy.Arn' "${TMP}/${AWS_POLICIES}_${AWS_EC2_LAMBDA_POLICY}_creation.json")"
  aws_attaching_policy_to_role ${AWS_EC2_LAMBDA_ROLE} "${NAMED_POLICY_ARN}"
fi
#AWS IAM LAMBDA: policy

#AWS LAMBDA: security groups
if [ -s "${TMP}/${AWS_SECURITY_GROUPS}_full.json" ]
then
  inf ""
  inf "${MAGENTA}Checking if security group ${YELLOW}${SECURITY_GROUP_LAMBDA_NAME}${MAGENTA} exists"
  SECURITY_GROUP_ID=$(jq -r --arg security_group_name ${SECURITY_GROUP_LAMBDA_NAME} '.SecurityGroups[] | select(.GroupName == $security_group_name) | .GroupId' "${TMP}/${AWS_SECURITY_GROUPS}_full.json")
  if [ ! -z ${SECURITY_GROUP_ID} ]
  then
    warn "  Security group: ${BROWN}${SECURITY_GROUP_LAMBDA_NAME}${WINE} already exists"
    SECURITY_GROUP_EXISTS="yes"
  else
    aws_ec2_security_group_create "${SECURITY_GROUP_LAMBDA_NAME}"
    aws ${AWS_PROFILE_USE_CHECK[*]} ec2 describe-security-groups > "${TMP}/${AWS_SECURITY_GROUPS}_full.json"
  fi
fi
inf "    ${MAGENTA}Checking if ${YELLOW}${SECURITY_GROUP_LAMBDA_NAME}${MAGENTA} has proper ingress configuration"
for SOURCE_NETWORK in ${SOURCE_NETWORKS[*]}
do
  (
  SECURITY_GROUP_INGRESS_SOURCE_NETWORK=$(jq -r --arg source_network ${SOURCE_NETWORK} '.SecurityGroups[].IpPermissions[].IpRanges[] | select(.CidrIp | startswith($source_network)) | .CidrIp' "${TMP}/${AWS_SECURITY_GROUPS}_full.json" | sort -u)
  if [ -z ${SECURITY_GROUP_INGRESS_SOURCE_NETWORK} ]
  then
    aws_security_group_ingress_add ${SECURITY_GROUP_ID} "${SOURCE_NETWORK}"
  else
    warn "      Source network: ${LIME}${SOURCE_NETWORK}${WINE} has already been added to security group: ${YELLOW}${SECURITY_GROUP_ID}"
  fi
  ) &
done
if [ ! -z ${EXTERNAL_INET_IP} ]
then
  if [[ ${EXTERNAL_INET_IP} =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]
  then
    aws_security_group_ingress_add ${SECURITY_GROUP_ID} "${EXTERNAL_INET_IP}/32"
  fi
fi
inf "    ${MAGENTA}Checking if ${YELLOW}${SECURITY_GROUP_LAMBDA_NAME}${MAGENTA} has proper egress configuration"
for EGRESS_ENTRY in ${AWS_EGRESS_LIST[*]}
do
  (
    aws_security_group_egress_add ${SECURITY_GROUP_ID} "${EGRESS_ENTRY}"
  ) &
done
wait
#AWS LAMBDA: security groups
END_DEPLOY_TIME=$(date +%s.%4N)
DEPLOY_TIME=$(echo "scale=4; x=(${END_DEPLOY_TIME} - ${START_DEPLOY_TIME}); if(x<1) print 0; x" | bc)

START_DEPLOY_LAMBDA_TIME=$(date +%s.%4N)
#AWS Lambda deployment
#ToDo: prepare the whole package for python things
if [ -s "${TMP}/${AWS_ROLES}_${AWS_EC2_LAMBDA_ROLE}_creation.json" ]
then
  export EC2_LAMBDA_ROLE_ARN=$(jq -r '.Role.Arn' "${TMP}/${AWS_ROLES}_${AWS_EC2_LAMBDA_ROLE}_creation.json")
fi

IFS=${NEWIFS}
if [ -s "${TMP}/${AWS_EVENTS_BUSES}_full.json" ]
then
  for EVENT_BUS in $(jq -r '.EventBuses[].Name' "${TMP}/${AWS_EVENTS_BUSES}_full.json")
  do
    EVENT_BUS_NAME=${EVENT_BUS}
    EVENT_BUS_ARN="$(jq -r --arg event_bus_name ${EVENT_BUS_NAME} '.EventBuses[] | select(.Name == $event_bus_name) | .Arn' "${TMP}/${AWS_EVENTS_BUSES}_full.json")"
    inf "  Event bus: ${DARK_GREEN}${EVENT_BUS_NAME}"
    if [ -s "${TMP}/${AWS_EVENTS_RULES}_full.json" ] && [ ! -z $(jq -r --arg aws_default_name ${AWS_DEFAULT_NAME} --arg event_bus_name ${EVENT_BUS_NAME} '.Rules[] | select(.Name | contains($aws_default_name) | not) | select(.EventBusName == $event_bus_name) | select(.ManagedBy == "schemas.amazonaws.com" | not) | .Name' "${TMP}/${AWS_EVENTS_RULES}_full.json" | head -n1) ]
    then
      for EVENT_RULE in $(jq -r --arg aws_default_name ${AWS_DEFAULT_NAME} --arg event_bus_name ${EVENT_BUS_NAME} '.Rules[] | select(.Name | contains($aws_default_name) | not) | select(.EventBusName == $event_bus_name) | select(.ManagedBy == "schemas.amazonaws.com" | not) | .Name' "${TMP}/${AWS_EVENTS_RULES}_full.json")
      do
        EVENT_RULE_NAME=${EVENT_RULE}
        EVENT_RULE_BUS=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .EventBusName' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        EVENT_RULE_SCHEDULE=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .ScheduleExpression' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        EVENT_RULE_ARN=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .Arn' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        EVENT_RULE_STATE=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .State' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        EVENT_RULE_DESCRIPTION=$(jq -r --arg event_rule_name ${EVENT_RULE_NAME} '.Rules[] | select(.Name == $event_rule_name) | .Description' "${TMP}/${AWS_EVENTS_RULES}_full.json")
        if [[ ${VERBOSE} == yes ]]
        then
          debug "    Event rule: ${LIME}${EVENT_RULE_NAME}${CYAN}, of this bus: ${DARK_GREEN}${EVENT_BUS_NAME}${CYAN}, scheduled on: ${BROWN}\"${EVENT_RULE_SCHEDULE}\""
        fi
        if [ -s "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json" ] && [ ! -z $(jq -r '.Targets[].Arn' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json" | head -n1) ]
        then
          for EVENT_TARGET_ARN in $(jq -r '.Targets[].Arn' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json" | sort -u)
          do
            (
            for EVENT_TARGET_ID in $(jq -r --arg event_target_arn ${EVENT_TARGET_ARN} '.Targets[] | select(.Arn == $event_target_arn) | .Id' "${TMP}/${AWS_EVENTS_RULES}_${EVENT_RULE}_targets_full.json")
            do
              if [[ ${VERBOSE} == yes ]]
              then
                debug "      to target Arn: ${GREEN}${EVENT_TARGET_ARN}" 
              fi
            done
            ) &
          done
          wait
        else
          warn "      There is no EventTargets related to rule: ${LIME}${EVENT_RULE_NAME}"
          event_bridge_remove_rule ${EVENT_RULE_NAME}
        fi
      done
    else
      warn "    There is no ${AWS_COMMON_NAME} EventRules related to the bus: ${DARK_GREEN}${EVENT_BUS_NAME}"
    fi
  done
else
  warn "  There is no ${AWS_COMMON_NAME} Event Buses yet"
fi
wait

for LAMBDA_SCRIPT_LINE in $(cat "${SCRIPTS_HOME}/lambda_functions/lambda_events.config" | grep -v "^#")
do
  LAMBDA_SCRIPT=$(echo "${LAMBDA_SCRIPT_LINE}" | awk -F\~ '{print $1}')
  LAMBDA_SCRIPT_NAME=$(echo ${LAMBDA_SCRIPT} | awk -F\. '{print $1}')
  SHELL_SCRIPT=$(echo "${LAMBDA_SCRIPT_LINE}" | awk -F\~ '{print $2}')
  SHELL_SCRIPT_NAME=$(echo ${SHELL_SCRIPT} | awk -F\. '{print $1}')
  SHELL_SCRIPT_CONTENT=$(cat "${SCRIPTS_HOME}/lambda_functions/${SHELL_SCRIPT}")
  RANDOM_ID_GEN=$(head -n10 /dev/urandom | tr -dc '0-9a-zA-Z' | fold -w 4 | head -n1)
  AWS_LAMBDA_NAME="${AWS_COMMON_NAME}_${SHELL_SCRIPT_NAME}_${LAMBDA_SCRIPT_NAME}"
  AWS_HANDLER_FUNCTION_NAME="${LAMBDA_SCRIPT_NAME}_handler"
  AWS_LAMBDA_HANDLER="${AWS_LAMBDA_NAME}.${AWS_HANDLER_FUNCTION_NAME}"
  export SHELL_SCRIPT_CONTENT
  export KEY_NAME
  export AWS_EC2_INSTANCES_PROFILE
  export AWS_HANDLER_FUNCTION_NAME
  export AWS_AMI_ID
  export AWS_INSTANCE_TYPE
  export SUBNET_ID
  export REGION
  export SECURITY_GROUP_ID
  inf "${MAGENTA}Checking if Lambda function (${YELLOW}${AWS_LAMBDA_NAME}${MAGENTA}) exists"
  lambda_function_deployment ${AWS_LAMBDA_NAME} ${AWS_HANDLER_FUNCTION_NAME}
  EVENT_TARGET_ID="Id=${RANDOM_ID_GEN},Arn=${EC2_LAMBDA_SCRIPT_ARN}"
  EVENT_SCHEDULE=$(echo "${LAMBDA_SCRIPT_LINE}" | awk -F\~ '{print $3}')
  if [ -z ${EVENT_SCHEDULE} ]
  then
    warn "    Lambda function: ${YELLOW}${AWS_LAMBDA_NAME}${WINE} is configured without schedule"
  else
    #only about naming convention
    if [[ ${EVENT_SCHEDULE} =~ ^cron.* ]]
    then
      SCHEDULE_DAY_OF_WEEK=$(echo ${EVENT_SCHEDULE} | awk -F\( '{print $2}' | awk '{print $5}')
      SCHEDULE_DAY_OF_MONTH=$(echo ${EVENT_SCHEDULE} | awk -F\( '{print $2}' | awk '{print $3}')
      if [[ ${SCHEDULE_DAY_OF_WEEK} == "?" ]] || [[ ${SCHEDULE_DAY_OF_WEEK} == "*" ]]
      then
        if [[ ${SCHEDULE_DAY_OF_MONTH} == "?" ]] || [[ ${SCHEDULE_DAY_OF_MONTH} == "*" ]]
        then
          EVENT_BRIDGE_RULE_NAME="$(echo ${EVENT_SCHEDULE} | awk -F\( '{print $2}' | awk '{print "HOUR_"$2"_MIN_"$1}' | sed 's/,/-/g')_lambda_rule_${RANDOM_ID_GEN}"
        else
          EVENT_BRIDGE_RULE_NAME="$(echo ${EVENT_SCHEDULE} | awk -F\( '{print $2}' | awk '{print "HOUR_"$2"_MIN_"$1"_MONTH_"$3}' | sed 's/,/-/g')_lambda_rule_${RANDOM_ID_GEN}"
        fi
      else
        if [[ ${SCHEDULE_DAY_OF_MONTH} == "?" ]] || [[ ${SCHEDULE_DAY_OF_MONTH} == "*" ]]
        then
          EVENT_BRIDGE_RULE_NAME="$(echo ${EVENT_SCHEDULE} | awk -F\( '{print $2}' | awk '{print "HOUR_"$2"_MIN_"$1"_DAY_"$5}' | sed 's/,/-/g')_lambda_rule_${RANDOM_ID_GEN}"
        else
          EVENT_BRIDGE_RULE_NAME="$(echo ${EVENT_SCHEDULE} | awk -F\( '{print $2}' | awk '{print "HOUR_"$2"_MIN_"$1"_DAY_"$5"_MONTH_"$3}' | sed 's/,/-/g')_lambda_rule_${RANDOM_ID_GEN}"
        fi
      fi
      EVENT_BRIDGE_EVENT_NAME=$(echo ${EVENT_BRIDGE_RULE_NAME} | sed 's/_rule/_event/g')
    elif [[ ${EVENT_SCHEDULE} =~ ^rate.* ]]
    then
      EVENT_SCHEDULE_RATE="$(echo ${EVENT_SCHEDULE} | awk -F\( '{print $2}' | awk '{print $1}')"
      EVENT_SCHEDULE_RANGE="$(echo ${EVENT_SCHEDULE} | awk -F\( '{print $2}' | awk '{print $2}' | awk -F\) '{print $1}')"
      EVENT_BRIDGE_RULE_NAME="every${EVENT_SCHEDULE_RATE}${EVENT_SCHEDULE_RANGE}_lambda_rule_${RANDOM_ID_GEN}"
      EVENT_BRIDGE_EVENT_NAME=$(echo ${EVENT_BRIDGE_RULE_NAME} | sed 's/_rule/_event/g')
    fi
    #only about naming convention end
    #actual checking, creating rules, and adding target to rules, and if needed, cleaning if attached to more then one rule
    if grep -q ${AWS_LAMBDA_NAME} "${TMP}/${AWS_EVENTS_RULES}_"*_targets_full.json
    then
      SID_FROM_EVENT=""
      lambda_get_policy ${AWS_LAMBDA_NAME}
      for TARGET_ALREADY_ADDED_TO_RULE_JSON in $(grep -l ${AWS_LAMBDA_NAME} "${TMP}/${AWS_EVENTS_RULES}_"*_targets_full.json)
      do
        for EXISTING_RULE_NAME in $(echo ${TARGET_ALREADY_ADDED_TO_RULE_JSON} | awk -F\/ '{print $NF}' | sed 's/_targets_full.json//g' | awk -F\. '{print $NF}' | sed "s/^.._//g")
        do
          for RULE_FILE in $(ls "${TMP}/aws_events-rules_${CURRENT_TIMESTAMP}_${EXISTING_RULE_NAME}_targets_full.json")
          do
            TARGET_ARN_CHECK=$(cat "${TMP}/aws_events-rules_${CURRENT_TIMESTAMP}_${EXISTING_RULE_NAME}_targets_full.json" | jq -r --arg aws_lambda_name ${AWS_LAMBDA_NAME} '.Targets[] | select(.Arn | contains($aws_lambda_name))' | jq -r '.Arn')
            TARGET_ID_CHECK=$(cat "${TMP}/aws_events-rules_${CURRENT_TIMESTAMP}_${EXISTING_RULE_NAME}_targets_full.json" | jq -r --arg aws_lambda_name ${AWS_LAMBDA_NAME} '.Targets[] | select(.Arn | contains($aws_lambda_name))' | jq -r '.Id')
          done
        done
      done
    else
      error "    This lambda: ${YELLOW}${AWS_LAMBDA_NAME}${RED} belongs to no event rule yet... (in fact as a target)"
      if [[ ${VERBOSE} == yes ]]
      then
        debug "      new name: EVENT_BRIDGE_RULE_NAME=${EVENT_BRIDGE_RULE_NAME}"
        debug "      new name: EVENT_BRIDGE_EVENT_NAME=${EVENT_BRIDGE_EVENT_NAME}"
        debug "      EVENT_SCHEDULE=${EVENT_SCHEDULE}"
        debug "      EVENT_TARGET_ID=${EVENT_TARGET_ID}"
      fi
      SID_FROM_EVENT=""
      lambda_get_policy ${AWS_LAMBDA_NAME}
      if [ ! -z ${SID_FROM_EVENT} ]
      then
        if [[ ${SID_FROM_EVENT} != ${EVENT_BRIDGE_EVENT_NAME} ]]
        then
          inf "        Something went wrong if there is no rule, but proper event bridge name (${EVENT_BRIDGE_RULE_NAME} already existed...)"
        else
          warn "        There is an old rule with different event name (generated ${DARK_GREEN}${EVENT_BRIDGE_EVENT_NAME}${WINE}, found from old trust: ${DARK_GREEN}${SID_FROM_EVENT}${WINE})"
          lambda_delete_permission ${AWS_LAMBDA_NAME} ${SID_FROM_EVENT}
        fi
      fi
    fi
  fi
  if [[ ${RUN_SCRIPT} == yes ]]
  then
    inf "  Invoking Lambda function ${YELLOW}${AWS_LAMBDA_NAME}${RED} (when event bridge will be configured properly this will be removed)"
    aws ${AWS_PROFILE_USE_CHECK[*]} lambda invoke --function-name ${AWS_LAMBDA_NAME} "${LOG}/${AWS_LAMBDA_FUNCTIONS}_${AWS_LAMBDA_NAME}_full.json" --log-type Tail --query 'LogResult' --output text |  base64 -d > "${LOG}/${AWS_LAMBDA_FUNCTIONS}_${AWS_LAMBDA_NAME}.log" 2>&1
    ERROR_CODE="$?"
    INSTANCE_ID_LAMBDA=$(grep "^i-" "${LOG}/${AWS_LAMBDA_FUNCTIONS}_${AWS_LAMBDA_NAME}.log")
    aws ${AWS_PROFILE_USE_CHECK[*]} ec2 describe-instances --instance-ids ${INSTANCE_ID_LAMBDA} > "${TMP}/${AWS_INSTANCES_DETAILS}_${INSTANCE_ID_LAMBDA}_full.json" 2>&1
    AWS_INSTANCE_DETAILS_IP=$(jq -r '.Reservations[].Instances[].PrivateIpAddress' "${TMP}/${AWS_INSTANCES_DETAILS}_${INSTANCE_ID_LAMBDA}_full.json")
    AWS_INSTANCE_DETAILS_PUBLIC_IP=$(jq -r '.Reservations[].Instances[].PublicIpAddress' "${TMP}/${AWS_INSTANCES_DETAILS}_${INSTANCE_ID_LAMBDA}_full.json")
    if [ -z ${AWS_INSTANCE_DETAILS_IP} ] || [[ ${AWS_INSTANCE_DETAILS_IP} == "null" ]]
    then
      error "    Instance hasn't been run, exiting"
      failed
    fi
    if [ -z ${AWS_INSTANCE_DETAILS_PUBLIC_IP} ] || [[ ${AWS_INSTANCE_DETAILS_PUBLIC_IP} == "null" ]]
    then
      inf "    Instance: ${YELLOW}${INSTANCE_ID_LAMBDA}${CYAN} with IP: ${LIME}${AWS_INSTANCE_DETAILS_IP}${CYAN} has just been created"
    else
      inf "  Instance: ${YELLOW}${INSTANCE_ID_LAMBDA}${CYAN} with private IP: ${LIME}${AWS_INSTANCE_DETAILS_IP}${CYAN} (public IP: ${GREEN}${AWS_INSTANCE_DETAILS_PUBLIC_IP}${CYAN}) has just been created"
    fi
    is_instance_up ${INSTANCE_ID_LAMBDA}
    ##AWS Lambda invoking
  fi
done
IFS=${ORIGIFS}

END_DEPLOY_LAMBDA_TIME=$(date +%s.%4N)
DEPLOY_LAMBDA_TIME=$(echo "scale=4; x=(${END_DEPLOY_LAMBDA_TIME} - ${START_DEPLOY_LAMBDA_TIME}); if(x<1) print 0; x" | bc)
